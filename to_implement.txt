- functionality from simple_tag:
	- homogeneous agents split into two swarms
	- single shared policy
	- team encoded in obs
- limited observability, view_radius
- all rewards individual, not global
- high performance: fully vectorised, squared distances only, batched obs/reward helpers
- position: 3D
- action: throttle to update heading: pitch, yaw, roll [-1, 1]
- action: no-fire/fire [-1, 1]
- battery
	- agents are given limited energy resources at the beginning of an episode
	- energy depleted per timestep, proportional to throttle
	- energy depleted by discrete amount per fire
	- if battery fully depleted, agent is deactivated
- fire behaviour:
	- area of effect: cone extends from agent in direction of heading
	- cone height and radius set by view_radius and cone_radius
	- if another agent is within this cone, it loses energy (same amount lost as it is to fire)
- collision behaviour:
	- agent-agent: both are deactivated
- observation:
	- relative pos and vel
	- ID (team agent, enemy agent, landmark)
- rewards:
	- small reward per timestep if within view_radius of landmark
	- small reward if fired on enemy this timestep
	- large reward if fired on enemy AND enemy deactivated
	- small penalty if fired on friendly
	- large penalty if fired on friendly AND friendly deactivated
	- large penalty if deactivated by enemy fire
	- large penalty if deactivated by collision with friendly
- episode end conditions:
	- when all agents of at least one team are wiped out / deactivated
	- when max timesteps are reached
- Perlin2D terrain gen
- landmarks spawn on terrain
- collision behaviour updated: agent-terrain collision results in agent deactivation
- rendering with PyVista


Curriculum:
- cones start as aoe, and become sharper over time


export VTK_DEFAULT_OPENGL_WINDOW=vtkEGLRenderWindow
export VTK_FORCE_MSAA=0

import os
os.environ["PYVISTA_OFF_SCREEN"] = "1"

import pyvista as pv
p = pv.Plotter(off_screen=True)

pv.global_theme.multi_samples = 0        # belt-and-braces: no MSAA
ok = p.enable_depth_peeling(number_of_peels=8, occlusion_ratio=0.0)
print("Depth peeling available?", ok)    # should be True on EGL

# sanity: make sure GL has alpha bits and MSAA is 0
rw = p.render_window
print("alpha bits:", rw.GetAlphaBitPlanes(), "MSAA:", rw.GetMultiSamples())

glyphs = landmarks.glyph(geom=sphere, orient=False, scale=False)
glyphs_clipped = glyphs.clip_box(bounds=(0,1,0,1,0,1))  # keep inside the unit cube
plotter.add_mesh(glyphs_clipped)
