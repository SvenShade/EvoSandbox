# Code for Perlin noise used under MIT license: https://github.com/puffy310/perlin-jax

import jax
import jax.numpy as jnp

def interpolant(t):
    return t*t*t*(t*(t*6 - 15) + 10)

def generate_perlin_noise_2d(
    shape, res, tileable=(False, False), interpolant=interpolant):
    def jax_auto():
        delta = (res[0] / shape[0], res[1] / shape[1])
        d = (shape[0] // res[0], shape[1] // res[1])
        grid = jnp.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
             .transpose(1, 2, 0) % 1
        # Gradients
        angles = 2*jnp.pi*np.random.rand(res[0]+1, res[1]+1)
        gradients = jnp.dstack((np.cos(angles), np.sin(angles)))
        if tileable[0]:
            gradients[-1,:] = gradients[0,:]
        if tileable[1]:
            gradients[:,-1] = gradients[:,0]
        gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
        g00 = gradients[    :-d[0],    :-d[1]]
        g10 = gradients[d[0]:     ,    :-d[1]]
        g01 = gradients[    :-d[0],d[1]:     ]
        g11 = gradients[d[0]:     ,d[1]:     ]
        # Ramps
        n00 = jnp.sum(jnp.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
        n10 = jnp.sum(jnp.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
        n01 = jnp.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
        n11 = jnp.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
        # Interpolation
    jax_auto = jax.vmap(jax_auto)
    jax.jit(jax_auto)
    t = interpolant(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return jnp.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)

def generate_fractal_noise_2d(
        shape, res, octaves=1, persistence=0.5,
        lacunarity=2, tileable=(False, False),
        interpolant=interpolant
):
    """Generate a 2D numpy array of fractal noise.

    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The, interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).

    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.

    Raises:
        ValueError: If shape is not a multiple of
            (lacunarity**(octaves-1)*res).
    """
    noise = np.zeros(shape)
    frequency = 1
    amplitude = 1
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(
            shape, (frequency*res[0], frequency*res[1]), tileable, interpolant
        )
        frequency *= lacunarity
        amplitude *= persistence
    return noise
  

def interpolate_heightmap(heightmap, drone_positions, world_size):
    """Interpolates terrain height at each drone's (x, y) position."""
    W, H = heightmap.shape
    world_x, world_y = world_size

    # Scale drone (x, y) to heightmap index space
    grid_x = (drone_positions[:, 0] / world_x) * (W - 1)
    grid_y = (drone_positions[:, 1] / world_y) * (H - 1)

    # Grid cell corners
    x0 = jnp.floor(grid_x).astype(jnp.int32)
    x1 = jnp.clip(x0 + 1, 0, W - 1)
    y0 = jnp.floor(grid_y).astype(jnp.int32)
    y1 = jnp.clip(y0 + 1, 0, H - 1)
    x0 = jnp.clip(x0, 0, W - 1)
    y0 = jnp.clip(y0, 0, H - 1)

    # Interpolation weights
    wx = grid_x - x0
    wy = grid_y - y0

    # Gather height values at corners
    h00 = heightmap[x0, y0]
    h01 = heightmap[x0, y1]
    h10 = heightmap[x1, y0]
    h11 = heightmap[x1, y1]

    # Bilinear interpolation
    terrain_z = (1 - wx) * (1 - wy) * h00 + \
                (1 - wx) * wy * h01 + \
                wx * (1 - wy) * h10 + \
                wx * wy * h11
    return terrain_z

def check_collisions(heightmap, drone_positions, world_size):
    """Returns boolean array: True if drone is below or within terrain."""
    drone_z = drone_positions[:, 2]
    terrain_z = interpolate_heightmap(heightmap, drone_positions, world_size)
    return drone_z <= terrain_z
